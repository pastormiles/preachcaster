#!/usr/bin/env python3
"""
08_generate_discussion_guide_v1.py
Generate printable PDF discussion guides for small groups.

================================================================================
OVERVIEW
================================================================================
This script creates beautifully formatted PDF discussion guides from the AI
content generated by script 07. These guides are designed for small group
leaders to use during weekly discussions.

This is a key Premium tier feature that provides tangible value to churches
beyond basic podcast automation.

================================================================================
DISCUSSION GUIDE CONTENTS
================================================================================
Each PDF guide includes:

1. HEADER
   - Church logo (optional)
   - Church name
   - "Small Group Discussion Guide" label
   - Sermon title
   - Date and speaker (if available)

2. SCRIPTURE FOCUS
   - Primary Bible passage with reference
   - Full or abbreviated text

3. THE BIG IDEA
   - Key takeaway from the sermon
   - Memorable, quotable format

4. ICEBREAKER
   - Casual opening question
   - Helps group warm up

5. DISCUSSION QUESTIONS
   - 5 thoughtful questions
   - Reference specific sermon content
   - Encourage genuine reflection

6. THIS WEEK'S CHALLENGE
   - Specific, actionable application
   - Connects sermon to daily life

7. PRAYER FOCUS
   - 2-3 prayer points
   - Related to sermon themes

8. GOING DEEPER
   - Supporting scripture references
   - For further personal study

================================================================================
INPUT/OUTPUT
================================================================================
INPUT:
  - AI content JSON file from script 07 (data/ai_content/{video_id}_ai_content.json)
  - Or ai_content_report.json for batch processing
  - Optional: Church logo image (PNG/JPG)

OUTPUT:
  - guides/{video_id}_discussion_guide.pdf
  - data/guides/guide_report.json (batch processing report)

================================================================================
USAGE
================================================================================
# Generate guide for single video
python 08_generate_discussion_guide_v1.py --video-id abc123xyz

# Generate from AI content report
python 08_generate_discussion_guide_v1.py --from-report data/ai_content/ai_content_report.json

# Process all AI content files
python 08_generate_discussion_guide_v1.py --all

# Auto-detect input
python 08_generate_discussion_guide_v1.py

# Custom branding
python 08_generate_discussion_guide_v1.py --video-id abc123 --logo path/to/logo.png

# Custom church name
python 08_generate_discussion_guide_v1.py --video-id abc123 --church-name "My Church"

# Force re-generate
python 08_generate_discussion_guide_v1.py --video-id abc123 --force

================================================================================
PDF LIBRARY
================================================================================
This script uses FPDF2 for PDF generation. It's a lightweight, pure-Python
library that doesn't require system dependencies.

Alternative libraries:
  - ReportLab: More powerful but steeper learning curve
  - WeasyPrint: HTML/CSS to PDF, requires system deps
  - pdfkit: Wrapper for wkhtmltopdf

================================================================================
DEPENDENCIES
================================================================================
pip install fpdf2 pillow

================================================================================
VERSION HISTORY
================================================================================
v1 (2025-01-01): Initial implementation
  - FPDF2-based PDF generation
  - Professional layout with sections
  - Church branding support
  - Batch processing

================================================================================
"""

import argparse
import json
import logging
import os
import sys
from datetime import datetime
from pathlib import Path
from typing import Optional

# Third-party imports
try:
    from fpdf import FPDF
    HAS_FPDF = True
except ImportError:
    HAS_FPDF = False

try:
    from PIL import Image
    HAS_PIL = True
except ImportError:
    HAS_PIL = False

try:
    from tqdm import tqdm
    HAS_TQDM = True
except ImportError:
    HAS_TQDM = False

# Try to import config
try:
    sys.path.insert(0, str(Path(__file__).parent.parent / "config"))
    from config import (
        AI_CONTENT_DIR, GUIDES_DIR, DATA_DIR, ASSETS_DIR,
        CHURCH_NAME, CHURCH_LOGO_PATH, CHURCH_PRIMARY_COLOR,
        CHURCH_SECONDARY_COLOR, ensure_directories
    )
    HAS_CONFIG = True
except ImportError:
    HAS_CONFIG = False
    AI_CONTENT_DIR = Path("data/ai_content")
    GUIDES_DIR = Path("guides")
    DATA_DIR = Path("data")
    ASSETS_DIR = Path("assets")
    CHURCH_NAME = "Your Church"
    CHURCH_LOGO_PATH = None
    CHURCH_PRIMARY_COLOR = "#1a365d"
    CHURCH_SECONDARY_COLOR = "#2b6cb0"

# =============================================================================
# Configuration
# =============================================================================

# PDF Settings
PAGE_WIDTH = 210  # A4 width in mm
PAGE_HEIGHT = 297  # A4 height in mm
MARGIN_LEFT = 15
MARGIN_RIGHT = 15
MARGIN_TOP = 15
MARGIN_BOTTOM = 15

# Font sizes
FONT_SIZE_TITLE = 18
FONT_SIZE_SECTION = 12
FONT_SIZE_BODY = 10
FONT_SIZE_SMALL = 9

# =============================================================================
# Logging Setup
# =============================================================================

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)


# =============================================================================
# Color Utilities
# =============================================================================

def hex_to_rgb(hex_color: str) -> tuple[int, int, int]:
    """
    Convert hex color to RGB tuple.
    
    Args:
        hex_color: Hex color string (e.g., "#1a365d")
        
    Returns:
        Tuple of (R, G, B) values 0-255
    """
    hex_color = hex_color.lstrip("#")
    return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))


# =============================================================================
# File Operations
# =============================================================================

def load_ai_content(video_id: str, ai_content_dir: Path) -> Optional[dict]:
    """
    Load AI content JSON file for a video.
    
    Args:
        video_id: YouTube video ID
        ai_content_dir: Directory containing AI content files
        
    Returns:
        AI content dict or None if not found
    """
    content_file = ai_content_dir / f"{video_id}_ai_content.json"
    
    if not content_file.exists():
        logger.warning(f"AI content not found: {content_file}")
        return None
    
    try:
        with open(content_file, 'r', encoding='utf-8') as f:
            return json.load(f)
    except json.JSONDecodeError as e:
        logger.error(f"Invalid JSON in {content_file}: {e}")
        return None
    except Exception as e:
        logger.error(f"Error loading {content_file}: {e}")
        return None


def find_ai_content_files(ai_content_dir: Path) -> list[Path]:
    """Find all AI content JSON files in directory."""
    if not ai_content_dir.exists():
        return []
    return sorted(ai_content_dir.glob("*_ai_content.json"))


def guide_exists(video_id: str, guides_dir: Path) -> bool:
    """Check if discussion guide already exists for a video."""
    guide_file = guides_dir / f"{video_id}_discussion_guide.pdf"
    return guide_file.exists()


def load_report(report_path: Path) -> Optional[dict]:
    """Load a processing report file."""
    try:
        with open(report_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception as e:
        logger.error(f"Error loading report {report_path}: {e}")
        return None


def save_report(report: dict, output_dir: Path) -> Path:
    """Save batch processing report."""
    output_dir.mkdir(parents=True, exist_ok=True)
    report_file = output_dir / "guide_report.json"
    
    with open(report_file, 'w', encoding='utf-8') as f:
        json.dump(report, f, indent=2, ensure_ascii=False)
    
    return report_file


# =============================================================================
# PDF Generator Class
# =============================================================================

class DiscussionGuidePDF(FPDF):
    """Custom PDF class for discussion guides."""
    
    def __init__(
        self,
        church_name: str = "Your Church",
        primary_color: str = "#1a365d",
        secondary_color: str = "#2b6cb0",
        logo_path: Optional[Path] = None
    ):
        super().__init__()
        self.church_name = church_name
        self.primary_color = hex_to_rgb(primary_color)
        self.secondary_color = hex_to_rgb(secondary_color)
        self.logo_path = logo_path
        
        # Set margins
        self.set_margins(MARGIN_LEFT, MARGIN_TOP, MARGIN_RIGHT)
        self.set_auto_page_break(True, MARGIN_BOTTOM)
        
        # Add Unicode font support
        self.add_page()
        
    def add_header(self, sermon_title: str, date: Optional[str] = None, speaker: Optional[str] = None):
        """Add document header with church branding."""
        # Logo (if available)
        logo_height = 0
        if self.logo_path and Path(self.logo_path).exists() and HAS_PIL:
            try:
                # Calculate logo dimensions (max height 15mm)
                self.image(str(self.logo_path), x=MARGIN_LEFT, y=MARGIN_TOP, h=15)
                logo_height = 18
            except Exception as e:
                logger.warning(f"Could not load logo: {e}")
        
        # Church name
        self.set_xy(MARGIN_LEFT + (40 if logo_height else 0), MARGIN_TOP)
        self.set_font("Helvetica", "B", 14)
        self.set_text_color(*self.primary_color)
        self.cell(0, 6, self.church_name, ln=True)
        
        # Subtitle
        self.set_font("Helvetica", "", 10)
        self.set_text_color(100, 100, 100)
        self.cell(0, 5, "Small Group Discussion Guide", ln=True)
        
        # Divider line
        y_pos = max(self.get_y(), MARGIN_TOP + logo_height) + 3
        self.set_y(y_pos)
        self.set_draw_color(*self.primary_color)
        self.set_line_width(0.5)
        self.line(MARGIN_LEFT, self.get_y(), PAGE_WIDTH - MARGIN_RIGHT, self.get_y())
        self.ln(5)
        
        # Sermon title
        self.set_font("Helvetica", "B", FONT_SIZE_TITLE)
        self.set_text_color(*self.primary_color)
        self.multi_cell(0, 8, sermon_title)
        
        # Date and speaker
        if date or speaker:
            self.set_font("Helvetica", "", FONT_SIZE_SMALL)
            self.set_text_color(100, 100, 100)
            info_parts = []
            if date:
                info_parts.append(date)
            if speaker:
                info_parts.append(speaker)
            self.cell(0, 5, "  |  ".join(info_parts), ln=True)
        
        self.ln(5)
    
    def add_section(self, title: str, content: str, is_list: bool = False):
        """
        Add a section with title and content.
        
        Args:
            title: Section title
            content: Section content (string or list items)
            is_list: If True, content is treated as list items
        """
        # Check if we need a new page
        if self.get_y() > PAGE_HEIGHT - 50:
            self.add_page()
        
        # Section title
        self.set_font("Helvetica", "B", FONT_SIZE_SECTION)
        self.set_text_color(*self.secondary_color)
        self.cell(0, 7, title.upper(), ln=True)
        
        # Content
        self.set_font("Helvetica", "", FONT_SIZE_BODY)
        self.set_text_color(40, 40, 40)
        
        if is_list and isinstance(content, list):
            for i, item in enumerate(content, 1):
                # Bullet or number
                self.set_x(MARGIN_LEFT + 3)
                self.set_font("Helvetica", "B", FONT_SIZE_BODY)
                self.cell(8, 6, f"{i}.")
                self.set_font("Helvetica", "", FONT_SIZE_BODY)
                
                # Calculate available width
                available_width = PAGE_WIDTH - MARGIN_LEFT - MARGIN_RIGHT - 11
                
                # Multi-line cell for the content
                self.multi_cell(available_width, 6, item)
                self.ln(1)
        else:
            self.multi_cell(0, 6, content)
        
        self.ln(4)
    
    def add_scripture_box(self, reference: str, text: str):
        """Add a highlighted scripture box."""
        # Check for page break
        if self.get_y() > PAGE_HEIGHT - 60:
            self.add_page()
        
        # Section title
        self.set_font("Helvetica", "B", FONT_SIZE_SECTION)
        self.set_text_color(*self.secondary_color)
        self.cell(0, 7, "SCRIPTURE FOCUS", ln=True)
        
        # Box background
        box_y = self.get_y()
        self.set_fill_color(245, 247, 250)
        
        # Reference
        self.set_font("Helvetica", "B", FONT_SIZE_BODY)
        self.set_text_color(*self.primary_color)
        self.set_x(MARGIN_LEFT + 3)
        ref_cell_width = PAGE_WIDTH - MARGIN_LEFT - MARGIN_RIGHT - 6
        self.multi_cell(ref_cell_width, 6, reference, fill=True)
        
        # Text
        self.set_font("Helvetica", "I", FONT_SIZE_BODY)
        self.set_text_color(60, 60, 60)
        self.set_x(MARGIN_LEFT + 3)
        self.multi_cell(ref_cell_width, 6, f'"{text}"', fill=True)
        
        # Draw border
        box_height = self.get_y() - box_y + 2
        self.set_draw_color(*self.secondary_color)
        self.set_line_width(0.3)
        self.rect(MARGIN_LEFT, box_y - 1, PAGE_WIDTH - MARGIN_LEFT - MARGIN_RIGHT, box_height)
        
        self.ln(6)
    
    def add_big_idea_box(self, big_idea: str):
        """Add a highlighted big idea box."""
        # Check for page break
        if self.get_y() > PAGE_HEIGHT - 50:
            self.add_page()
        
        # Section title
        self.set_font("Helvetica", "B", FONT_SIZE_SECTION)
        self.set_text_color(*self.secondary_color)
        self.cell(0, 7, "THE BIG IDEA", ln=True)
        
        # Box
        box_y = self.get_y()
        self.set_fill_color(*self.primary_color)
        self.set_text_color(255, 255, 255)
        self.set_font("Helvetica", "B", 11)
        
        # Add padding
        self.set_x(MARGIN_LEFT)
        box_width = PAGE_WIDTH - MARGIN_LEFT - MARGIN_RIGHT
        
        # Calculate text height
        self.multi_cell(box_width - 10, 7, big_idea, fill=True, align='C')
        
        self.ln(6)
    
    def add_bullet_section(self, title: str, items: list[str]):
        """Add a section with bullet points."""
        # Check for page break
        if self.get_y() > PAGE_HEIGHT - 50:
            self.add_page()
        
        # Section title
        self.set_font("Helvetica", "B", FONT_SIZE_SECTION)
        self.set_text_color(*self.secondary_color)
        self.cell(0, 7, title.upper(), ln=True)
        
        # Bullet items
        self.set_font("Helvetica", "", FONT_SIZE_BODY)
        self.set_text_color(40, 40, 40)
        
        for item in items:
            self.set_x(MARGIN_LEFT + 3)
            self.cell(5, 6, "-")
            available_width = PAGE_WIDTH - MARGIN_LEFT - MARGIN_RIGHT - 8
            self.multi_cell(available_width, 6, item)
        
        self.ln(4)
    
    def add_going_deeper(self, scriptures: list[dict]):
        """Add going deeper section with scripture references."""
        if not scriptures:
            return
        
        # Check for page break
        if self.get_y() > PAGE_HEIGHT - 30:
            self.add_page()
        
        # Section title
        self.set_font("Helvetica", "B", FONT_SIZE_SECTION)
        self.set_text_color(*self.secondary_color)
        self.cell(0, 7, "GOING DEEPER", ln=True)
        
        # Scripture references
        self.set_font("Helvetica", "", FONT_SIZE_SMALL)
        self.set_text_color(80, 80, 80)
        
        refs = [s.get("reference", "") for s in scriptures if s.get("reference")]
        self.cell(0, 5, "  |  ".join(refs), ln=True)
        
        self.ln(4)


# =============================================================================
# Guide Generation
# =============================================================================

def generate_discussion_guide(
    ai_content: dict,
    output_dir: Path,
    church_name: str = CHURCH_NAME,
    logo_path: Optional[Path] = None,
    primary_color: str = CHURCH_PRIMARY_COLOR,
    secondary_color: str = CHURCH_SECONDARY_COLOR
) -> Optional[Path]:
    """
    Generate a discussion guide PDF from AI content.
    
    Args:
        ai_content: AI content dict from script 07
        output_dir: Output directory for PDF
        church_name: Church name for branding
        logo_path: Path to church logo image
        primary_color: Primary brand color (hex)
        secondary_color: Secondary brand color (hex)
        
    Returns:
        Path to generated PDF or None on failure
    """
    if not HAS_FPDF:
        logger.error("FPDF2 not installed. Run: pip install fpdf2")
        return None
    
    video_id = ai_content.get("video_id", "unknown")
    title = ai_content.get("title", "Sermon Discussion Guide")
    
    try:
        # Create PDF
        pdf = DiscussionGuidePDF(
            church_name=church_name,
            primary_color=primary_color,
            secondary_color=secondary_color,
            logo_path=logo_path
        )
        
        # Header
        date_str = None
        if "generated_at" in ai_content:
            try:
                dt = datetime.fromisoformat(ai_content["generated_at"].replace("Z", "+00:00"))
                date_str = dt.strftime("%B %d, %Y")
            except Exception:
                pass
        
        pdf.add_header(title, date=date_str)
        
        # Scripture Focus
        primary_scripture = ai_content.get("primary_scripture", {})
        if primary_scripture:
            pdf.add_scripture_box(
                primary_scripture.get("reference", "Scripture Reference"),
                primary_scripture.get("text", "")
            )
        
        # Big Idea
        big_idea = ai_content.get("big_idea", "")
        if big_idea:
            pdf.add_big_idea_box(big_idea)
        
        # Discussion Guide Content
        discussion_guide = ai_content.get("discussion_guide", {})
        
        # Icebreaker
        icebreaker = discussion_guide.get("icebreaker", "")
        if icebreaker:
            pdf.add_section("Icebreaker", icebreaker)
        
        # Discussion Questions
        questions = discussion_guide.get("questions", [])
        if questions:
            pdf.add_section("Discussion Questions", questions, is_list=True)
        
        # This Week's Challenge
        application = discussion_guide.get("application", "")
        if application:
            pdf.add_section("This Week's Challenge", application)
        
        # Prayer Focus
        prayer_points = discussion_guide.get("prayer_points", [])
        if prayer_points:
            pdf.add_bullet_section("Prayer Focus", prayer_points)
        
        # Going Deeper
        supporting_scriptures = ai_content.get("supporting_scriptures", [])
        if supporting_scriptures:
            pdf.add_going_deeper(supporting_scriptures)
        
        # Save PDF
        output_dir.mkdir(parents=True, exist_ok=True)
        output_path = output_dir / f"{video_id}_discussion_guide.pdf"
        pdf.output(str(output_path))
        
        logger.info(f"Generated: {output_path}")
        return output_path
        
    except Exception as e:
        logger.error(f"Error generating PDF for {video_id}: {e}")
        return None


# =============================================================================
# Batch Processing
# =============================================================================

def process_video(
    video_id: str,
    ai_content_dir: Path,
    output_dir: Path,
    church_name: str,
    logo_path: Optional[Path],
    primary_color: str,
    secondary_color: str,
    force: bool = False
) -> dict:
    """
    Process a single video to generate discussion guide.
    
    Args:
        video_id: YouTube video ID
        ai_content_dir: Directory containing AI content files
        output_dir: Output directory for PDFs
        church_name: Church name for branding
        logo_path: Path to church logo
        primary_color: Primary brand color
        secondary_color: Secondary brand color
        force: Force regeneration
        
    Returns:
        Result dict with status and details
    """
    result = {
        "video_id": video_id,
        "status": "pending",
        "output_file": None,
        "error": None
    }
    
    # Check if already exists
    if not force and guide_exists(video_id, output_dir):
        result["status"] = "skipped"
        result["output_file"] = str(output_dir / f"{video_id}_discussion_guide.pdf")
        return result
    
    # Load AI content
    ai_content = load_ai_content(video_id, ai_content_dir)
    if not ai_content:
        result["status"] = "failed"
        result["error"] = "AI content not found"
        return result
    
    # Check for required fields
    if not ai_content.get("discussion_guide"):
        result["status"] = "failed"
        result["error"] = "No discussion guide content in AI content"
        return result
    
    # Generate PDF
    output_path = generate_discussion_guide(
        ai_content,
        output_dir,
        church_name=church_name,
        logo_path=logo_path,
        primary_color=primary_color,
        secondary_color=secondary_color
    )
    
    if output_path:
        result["status"] = "success"
        result["output_file"] = str(output_path)
    else:
        result["status"] = "failed"
        result["error"] = "PDF generation failed"
    
    return result


def process_batch(
    video_ids: list[str],
    ai_content_dir: Path,
    output_dir: Path,
    church_name: str,
    logo_path: Optional[Path],
    primary_color: str,
    secondary_color: str,
    force: bool = False,
    quiet: bool = False
) -> dict:
    """
    Process multiple videos.
    
    Args:
        video_ids: List of video IDs
        ai_content_dir: AI content directory
        output_dir: Output directory
        church_name: Church name
        logo_path: Logo path
        primary_color: Primary color
        secondary_color: Secondary color
        force: Force regeneration
        quiet: Suppress output
        
    Returns:
        Batch report dict
    """
    report = {
        "generated_at": datetime.now().isoformat(),
        "church_name": church_name,
        "total_videos": len(video_ids),
        "results": {
            "success": 0,
            "skipped": 0,
            "failed": 0
        },
        "videos": []
    }
    
    # Progress iterator
    if HAS_TQDM and not quiet:
        iterator = tqdm(video_ids, desc="Generating guides")
    else:
        iterator = video_ids
    
    for video_id in iterator:
        result = process_video(
            video_id,
            ai_content_dir,
            output_dir,
            church_name,
            logo_path,
            primary_color,
            secondary_color,
            force
        )
        
        report["results"][result["status"]] = report["results"].get(result["status"], 0) + 1
        report["videos"].append(result)
        
        if not quiet and not HAS_TQDM:
            status_symbol = {"success": "✓", "skipped": "○", "failed": "✗"}
            print(f"  {status_symbol.get(result['status'], '?')} {video_id}: {result['status']}")
    
    return report


# =============================================================================
# Input Detection
# =============================================================================

def get_video_ids_from_input(args, ai_content_dir: Path) -> list[str]:
    """
    Determine video IDs to process based on CLI arguments.
    
    Args:
        args: Parsed CLI arguments
        ai_content_dir: AI content directory
        
    Returns:
        List of video IDs to process
    """
    video_ids = []
    
    # Single video ID
    if args.video_id:
        return [args.video_id]
    
    # Multiple video IDs
    if args.video_ids:
        return [v.strip() for v in args.video_ids.split(",") if v.strip()]
    
    # From report file
    if args.from_report:
        report_path = Path(args.from_report)
        report = load_report(report_path)
        if report and "videos" in report:
            video_ids = [v["video_id"] for v in report["videos"] if v.get("status") == "success"]
        return video_ids
    
    # All AI content files
    if args.all:
        content_files = find_ai_content_files(ai_content_dir)
        return [f.stem.replace("_ai_content", "") for f in content_files]
    
    # Auto-detect: check for ai_content_report.json
    report_file = ai_content_dir / "ai_content_report.json"
    if report_file.exists():
        report = load_report(report_file)
        if report and "videos" in report:
            return [v["video_id"] for v in report["videos"] if v.get("status") == "success"]
    
    # Fallback: all AI content files
    content_files = find_ai_content_files(ai_content_dir)
    return [f.stem.replace("_ai_content", "") for f in content_files]


# =============================================================================
# CLI Interface
# =============================================================================

def parse_args():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Generate PDF discussion guides from AI content",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s --video-id abc123xyz
  %(prog)s --from-report data/ai_content/ai_content_report.json
  %(prog)s --all
  %(prog)s --video-id abc123 --logo assets/logo.png
  %(prog)s --video-id abc123 --church-name "My Church"
        """
    )
    
    # Input options
    input_group = parser.add_argument_group("Input Options")
    input_group.add_argument(
        "--video-id",
        help="Generate guide for single video"
    )
    input_group.add_argument(
        "--video-ids",
        help="Generate guides for multiple videos (comma-separated)"
    )
    input_group.add_argument(
        "--from-report",
        help="Generate guides from a report file"
    )
    input_group.add_argument(
        "--all",
        action="store_true",
        help="Generate guides for all AI content files"
    )
    
    # Branding options
    brand_group = parser.add_argument_group("Branding Options")
    brand_group.add_argument(
        "--church-name",
        default=CHURCH_NAME,
        help=f"Church name for header (default: {CHURCH_NAME})"
    )
    brand_group.add_argument(
        "--logo",
        type=Path,
        default=CHURCH_LOGO_PATH if HAS_CONFIG else None,
        help="Path to church logo image (PNG/JPG)"
    )
    brand_group.add_argument(
        "--primary-color",
        default=CHURCH_PRIMARY_COLOR,
        help=f"Primary brand color (hex, default: {CHURCH_PRIMARY_COLOR})"
    )
    brand_group.add_argument(
        "--secondary-color",
        default=CHURCH_SECONDARY_COLOR,
        help=f"Secondary brand color (hex, default: {CHURCH_SECONDARY_COLOR})"
    )
    
    # Processing options
    proc_group = parser.add_argument_group("Processing Options")
    proc_group.add_argument(
        "--force",
        action="store_true",
        help="Force regeneration even if guide exists"
    )
    
    # Output options
    output_group = parser.add_argument_group("Output Options")
    output_group.add_argument(
        "--quiet", "-q",
        action="store_true",
        help="Suppress progress output"
    )
    
    # Directory overrides
    dir_group = parser.add_argument_group("Directory Overrides")
    dir_group.add_argument(
        "--ai-content-dir",
        type=Path,
        default=AI_CONTENT_DIR,
        help="AI content directory"
    )
    dir_group.add_argument(
        "--output-dir",
        type=Path,
        default=GUIDES_DIR,
        help="Output directory for PDFs"
    )
    
    return parser.parse_args()


def main():
    """Main entry point."""
    args = parse_args()
    
    # Check dependencies
    if not HAS_FPDF:
        print("ERROR: FPDF2 library not installed.")
        print("Install with: pip install fpdf2")
        sys.exit(1)
    
    # Set up logging
    if args.quiet:
        logging.getLogger().setLevel(logging.WARNING)
    
    # Ensure directories exist
    if HAS_CONFIG:
        try:
            ensure_directories()
        except Exception:
            pass
    args.output_dir.mkdir(parents=True, exist_ok=True)
    
    # Create guides data dir for report
    guides_data_dir = DATA_DIR / "guides" if HAS_CONFIG else Path("data/guides")
    guides_data_dir.mkdir(parents=True, exist_ok=True)
    
    # Get video IDs to process
    video_ids = get_video_ids_from_input(args, args.ai_content_dir)
    
    if not video_ids:
        if not args.quiet:
            print("No videos to process.")
            print(f"  AI content directory: {args.ai_content_dir}")
            print("  Provide --video-id, --from-report, or ensure AI content files exist")
        sys.exit(1)
    
    # Process
    if not args.quiet:
        print(f"\nGenerating discussion guides for {len(video_ids)} video(s)")
        print(f"  AI Content: {args.ai_content_dir}")
        print(f"  Output: {args.output_dir}")
        print(f"  Church: {args.church_name}")
        if args.logo:
            print(f"  Logo: {args.logo}")
        print()
    
    report = process_batch(
        video_ids,
        args.ai_content_dir,
        args.output_dir,
        args.church_name,
        args.logo,
        args.primary_color,
        args.secondary_color,
        args.force,
        args.quiet
    )
    
    # Save report
    report_file = save_report(report, guides_data_dir)
    
    # Print summary
    if not args.quiet:
        print(f"\n{'='*60}")
        print("SUMMARY")
        print(f"{'='*60}")
        
        results = report["results"]
        print(f"  Success: {results.get('success', 0)}")
        print(f"  Skipped: {results.get('skipped', 0)}")
        print(f"  Failed:  {results.get('failed', 0)}")
        
        print(f"\nReport saved: {report_file}")
        print(f"Guides saved to: {args.output_dir}")
    
    # Exit code based on results
    if report["results"].get("failed", 0) > 0:
        sys.exit(1)
    sys.exit(0)


if __name__ == "__main__":
    main()
